# 명령어와 구조
## 연산 코드와 오퍼랜드
명령어는 '무엇을 대상으로, 어떤 동작을 수행하라'는 구조로 되어있다.  

**명령어**는 연산 코드와 오퍼랜드로 구성되어 있다.  

'명령어가 수행할 연산'을 **연산 코드(operation code)**라 하고, '연산에 사용할 데이터' 또는 '연산에 사용할 데이터가 저장된 위치'를 **오퍼랜드(operand)**라고 한다.  
- 예를 들어, '100과 120을 더해라'에서 '100과'와 '120을' 은 오퍼랜드이며, '더해라'는 연산 코드이다.


연산 코드는 **연산자**, 오퍼랜드는 **피연산자**라고도 부른다.  

기계어와 어셈블리어 또한 명령어이기 때문에 연산 코드와 오퍼랜드로 구성되어 있다.  

> push rbp  
> mov rbp, rsp  
> mov DWORD PTR [rbp-4], 1  
> mov DWORD PTR [rbp-8], 2  
> mov edx, DWORD PTR [rbp-4]  
> mov eax, DWORD PTR [rbp-8]  
> add eax, edx  
> mov DWORD PTR [rbp-12], eax  
> mov eax, 0  
> pop rbp  
> ret  

여기서 앞의 push, mov, add, pop, ret 등은 연산 코드이고 그 뒤의 명령어는 오퍼랜드이다.  

### 오퍼랜드
오퍼랜드는 '연산에 사용할 데이터' 또는 '연산에 사용할 데이터가 저장된 위치'를 의미한다고 했다.  

그래서 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있다.
- 다만 오퍼랜드 필드에는 숫자나 문자와 같이 연산에 사용할 데이터를 직접 명시하기보다는, 많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다. 그래서 오퍼랜드 필드를 **주소 필드**라고 부르기도 한다.  

오퍼 랜드는 명령어 안에 하나도 없을 수도 있고, 한 개만 있을 수도 있고, 두 개 또는 세 개 등 여러개가 있을수도 있다.
- 여기서 오퍼랜드가 하나도 없는 명령어를 **0-주소 명령어**라고 하고, 오퍼랜드가 하나인 명령어를 **1-주소 명령어**, 두 개인 명령어를 **2-주소 명령어**, 세 개인 명령어를 **3-주소 명령어**라고 한다.  
  - ret < 0-주소 명령어
  - push rbp < 1-주소 명령어
  - mov rbp, rsp < 2-주소 명령어

오퍼랜드 필드에는 연산에 사용할 데이터를 직접 명시하기보다는 많은 경우 데이터가 저장된 위치를 명시한다는 사실을 기억해두자.  

### 연산 코드
연산 코드는 '더해라', '빼라', '저장해라'와 같이 해당하는 부분이 연산 코드이다.  

연산 코드의 종류는 매우 많지만, 가장 기본적인 연산 코드 유형은 크게 4가지로 나눌 수 있다.
1. 데이터 전송
2. 산술/논리 연산
3. 제어 흐름 변경
4. 입출력 제어

이 4가지 유형 각각에 해당하는 대표적인 연산 코드를 알아보자. 단, 명령어의 종류와 생김새는 CPU마다 다르기 때문에 연산 코드의 종류와 생김새 또한 CPU마다 다르다.

이 다음의 연산 코드들은 대부분의 CPU가 공통으로 이해하는 대표적인 연산 코드의 종류 정도로만 이해하면 된다.  

**데이터 전송**
- MOVE: 데이터를 옮겨라
- STORE: 메모리에 저장하라
- LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라
- PUSH: 스택에 데이터를 저장하라
- POP: 스택의 최상단 데이터를 가져와라  

**산술/논리 연산**
- ADD / SUBTRACT / MULTIPLY / DIVIDE: 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라
- INCREMENT / DECREMENT: 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
- AND / OR / NOT: AND / OR / NOT 연산을 수행하라
- COMPARE: 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라  

**제어 흐름 변경**
- JUMP: 특정 주소로 실행 순서를 옮겨라
- CONDITIONAL JUMP: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
- HALT: 프로그램의 실행을 멈춰라
- CALL: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
- RETURN: CALL을 호출할 때 저장했던 주소로 돌아가라  

**입출력 제어**
- READ(INPUT): 특정 입출력 장치로부터 데이터를 읽어라
- WRITE(OUTPUT): 특정 입출력 장치로 데이터를 써라
- START IO: 입출력 장치를 시작하라
- TEST IO: 입출력 장치의 상태를 확인하라  

## 주소 지정 방식
오퍼랜드 필드에 데이터가 많을경우 메모리나 레지스터의 주소를 담는경우가 많다고했다.

> 하나의 명령어가 n비트로 구성되어 있고, 그중 연산 코드 필드가 m비트라고 가정해보자.  
> 
> 이때, 오퍼랜드 필드에 가장 많은 공간을 할당할 수 있는 1-주소 명령어라 할지라도 오퍼랜드 필드의 길이는 연산 코드길이만큼의 길이를 뺀 n-m 비트가 된다. 2-주소 명령어, 3-주소 명령어라면 오퍼랜드 필드의 크기는 더욱 작아진다.  
>
> 명령어의 크키가 16비트, 연산 코드 필드가 4비트인 2-주소 명령어에서는 오퍼랜드 필드당 6비트밖에 남지 않는다. 즉, 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 $2^6$개밖에 되지 않는다.
>
> 그리고 명령어 크기가 16비트, 연산 코드 필드가 4비트인 3-주소 명령어에서는 오퍼랜드 필드당 4비트밖에 남지 않는다. 그리고 표현할 수 있는 정보의 가짓수는 $2^4$개밖에 안된다.

하지만, 만약 오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.  

예를 들어 한 주소에 16비트를 저장할 수 있는 메모리가 있다고 가정해보자.  
이 메모리 안에 데이터를 저장하고, 오퍼랜드 필드 안에 해당 메모리 주소를 명시한다면 표현할 수 있는 정보의 가짓수가 2의 16제곱으로 확 커진다. 이는 오퍼랜드 필드에 메모리 주소가 아닌 레지스터 이름을 명시할 때도 마찬가지이다.  
> 이와 같이 연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치를  
> **유효 주소(effective address)**라고 한다.

> 이렇듯 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을  
> **주소 지정 방식(addressing mode)**이라고 한다. 다시말해, 주소 지정 방식은 유효 주소를 찾는 방법이라는 말이다.

### 즉시 주소 지정 방식
**즉시 주소 지정 방식(immediate addressing mode)**은 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식이다.