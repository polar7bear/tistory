# HTTP의 무상태성과 비연결성

# 무상태성(Stateless)

**무상태성**은 우선 한마디로 정의하자면 **클라이언트와 서버 사이의 상태를 유지하지 않는 것**을 의미한다.

이게 무슨 말인가 하면, 서버는 클라이언트로부터 요청을 받으면 응답을 보내는 역할만 수행하고,

상태 관리는 전적으로 클라이언트에게 책임이 있다는 것이다.

즉, 서버는 클라이언트의 상태 정보를 기억하지 않는다는 것이다. → 이로 인해 여러 서버에서 응답이 가능함.

예시)

<aside>
💡 손님 : 소설책 위치를 알고 싶어요.

직원A : 소설책은 C5구역에 있습니다.

손님 : C5 구역에 있는 소설책 2권 구매할게요.

직원B : 소설책 2권 30,000원입니다.

손님 : C5 구역에 있는 소설책 2권 구매할게요. 현금으로 결제 할게요.

직원C : 결제 되었습니다.

</aside>

위의 예시에서 직원(서버)들은 손님이 무슨 책을 찾는지, 무슨 책을 구매하였는지 기억하지 못한다.

하지만, 손님(클라이언트)이 자신의 행동을 기억하고 있다면 중간에 다른 직원으로 바뀌어도 책을 찾고 그 책을 구매할 수 있다는 것이다.

### 무상태성의 장단점 및 특징

### 장점

- **독립적인 요청 처리 -** 서버는 각 요청을 별개의 독립적인 이벤트로 간주하며, 한 요청의 처리가 끝나면 그 요청에 대한 모든 정보는 사라진다.
- **성능 최적화** - 서버가 클라이언트의 정보를 기억할 필요가 없기 때문에, 많은 사용자의 요청을 빠르게 처리할 수 있다.
- **확장성** - 상태 정보가 없기 때문에, 요청은 어느 서버에서도 처리될 수 있다. 이는 [로드 밸런싱](https://aws.amazon.com/ko/what-is/load-balancing/)과 [분산 시스템](https://www.atlassian.com/ko/microservices/microservices-architecture/distributed-architecture)에서의 확장성을 향상 시킨다.

 

### 단점

- **상태 유지의 필요성** - 많은 웹 애플리케이션에서는 사용자의 상태 정보(ex. 로그인 상태, 장바구니의 아이템들 등)를 유지해야 한다. HTTP의 무상태성으로 인해 이런 상태 정보의 유지가 지원되지 않는다. → 이를 해결하기 위해서는?

## 상태유지(Stateful)

**상태 유지**는 무상태성(stateless)과는 반대로 클라이언트로부터 요청을 받은 **서버가 클라이언트의 상태를 보존**하는 것을 의미한다.

→ 서버에서 클라이언트가 **이전 단계들에서 제공한 값들을 저장하고 다음 단계에서도 저장한 상태**임

예시)

<aside>
💡 손님 : 소설책 위치를 알고 싶어요.

직원A : 소설책은 C5구역에 있습니다.

손님 : 2권 구매할게요 얼마인가요?

직원A : 30,000원입니다.    (C5구역에 있는 소설책 2권 보존)

손님 : C5 구역에 있는 소설책 2권 구매할게요. 현금으로 결제 할게요.

직원A : 결제 되었습니다.   (C5구역에 있는 소설책 2권 현금으로 결제 보존)

</aside>

무상태성의 예시와 똑같은 예시로 들어보면,

stateless는 상태를 보존하지 않기 때문에 여러 서버(ex.여러 직원)에서 처리가 가능 했던 반면에, 

**stateful은 클라이언트의 상태를 오직 하나의 서버에서만 저장**하고 있다. 

대표적으로는 웹사이트에서 로그인을 하면 페이지를 이동해도 로그인이 풀리지 않고 계속 유지되는 것이 바로 서버가 클라이언트의 상태를 유지하고 있으니까 가능한 것임.

→ 이러한 클라이언트의 상태 정보를 **쿠키나 세션 혹은 토큰에 저장하여 상태를 유지**함.

![웹사이트에서 개발자 도구를 열어서 세션을 확인해보면 로그인을 한 정보가 세션에 저장되어 있음.](https://prod-files-secure.s3.us-west-2.amazonaws.com/5dfd688f-df73-4aa1-b016-d479762c28f9/1088f6f9-ca78-4f8b-a5de-45dae7d7217e/Untitled.png)

웹사이트에서 개발자 도구를 열어서 세션을 확인해보면 로그인을 한 정보가 세션에 저장되어 있음.

### 상태 유지의 문제점

- 만약 대량의 트래픽으로 인해 서버를 증설 시켰고, 그 증설된 다른 서버가 클라이언트의 요청을 이어 받는다고 가정해보자.
- 다른 서버가 요청을 이어 받으려면 그 이전의 요청들이 저장이 되어 있지 않은 상태 → 문제 발생

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5dfd688f-df73-4aa1-b016-d479762c28f9/35d5e0b1-499d-413e-be9f-13fa409bb960/Untitled.png)

클라이언트 상태들을 저장 하고 있으니 용량 한계 존재

- 현업에서는 이러한 클라이언트 상태 데이터를 캐시 서버(Redis)에 저장하여 이용함.

---

# 비연결성(Connectionless)

!https://blog.kakaocdn.net/dn/BIhCp/btrRdeNxWNb/0f8qCi0nSs2C8og5l9zZ9k/img.png

HTTP 프로토콜의 특성인 **비연결성**은 클라이언트가 서버에 요청을 보내면 서버는 **클라이언트에게 해당 응답을 보내고, 그 후 클라이언트와의 연결을 끊는 것**을 말한다.

### 클라이언트와 서버가 연결을 계속 유지한다면 ? (연결성)

!https://blog.kakaocdn.net/dn/tJOlB/btrRfI7VZTx/OkKyyCfrf1Kt70EZELYzY1/img.png

## 비연결성 장단점 및 특징

### 장점

- **리소스 효율** - 연결을 계속 유지하는 것보다 많은 수의 클라이언트 요청을 순차적으로 빠르게 처리하여 리소스를 효율적으로 사용할 수 있다.
- **동시 접속자 처리** - 대량의 동시 접속자에 대해 연결을 유지할 필요가 없으므로, 많은 수의 동시 접속자를 처리할 수 있음.

### 단점

- **상태 유지의 어려움** - 연결이 끊어진 후에는 이전 요청에 대한 정보가 없기 때문에, 클라이언트의 상태를 유지하는 것이 어렵다.
- **연결 설정과 종료 오버헤드** - 각 요청마다 새로운 연결을 설정하고 종료하는 오버헤드가 발생한다.
    - 여기서 **오버헤드**란 어떤 처리를 하기 위해 들어가는 간접적인 처리를 하는 시간이나 메모리 등을 말함.
    - 이러한 문제를 **HTTP Persistent Connections(영속적인 커넥션)**으로 해결하고 있음.

### HTTP Persistent Connections(영속적인 커넥션)

비연결성의 특징인 새로운 연결을 맺을 때마다 드는 상당한 시간이 드는 문제를 완화 시키기 위한 방법이며, Keep-Alive라고도 함.

클라이언트와 서버 간의 **연결을 열어 놓고 여러 요청에 재사용**을 함으로써, 새로운 TCP/IP연결의 3 way handshake 비용을 아끼게 되고 연결의 오버헤드가 감소 함.

하지만, 연결이 열려 있는 동안 서버와 클라이언트 양쪽 모두에서 리소스(메모리, 소켓)가 사용됨. 이는 **많은 수의 동시 연결에서는 리소스 부족 문제를 일으킬 수 있음**.
